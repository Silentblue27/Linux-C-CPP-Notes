# Linux C/C++

## 运维命令总结

```
sudo system status <进程>	//查看进程状态
```

```
htop或glances	//监控实时状态
```

```
netstat -tulnp | grep <端口号>
```

websocket测试实例：

```js
const WebSocket = require('ws');
const fs = require('fs');
const wss = new WebSocket.Server({ port: 8080 });
const dataPath = '/home/silentblue/received_data/';  // 数据存储路径

// 确保数据目录存在
if (!fs.existsSync(dataPath)) {
  fs.mkdirSync(dataPath, { recursive: true });
}

wss.on('connection', (ws) => {
  ws.on('message', (message) => {
    try {
      const jsonData = JSON.parse(message);
      const filename = `data_${Date.now()}.json`;
      fs.writeFileSync(`${dataPath}${filename}`, JSON.stringify(jsonData, null, 2));
      console.log(`Saved JSON to ${filename}`);
    } catch (e) {
      console.error('Invalid JSON:', e.message);
    }
  });
});

console.log('Server running on ws://8.134.251.166:8080');
```

websocket实时监测日志：

```
sudo journalctl -u websocket.service -f
```

换源：

```
vim /etc/apt/sources.list
```

```
deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse
```

更新：

```
sudo apt update && sudo apt upgrade -y
```

## VSCODE Windows配置

C

task.json的多文件编译

```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe build active file",
            "command": "D:\\software\\msys64\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                // "${file}",	//注释掉
                "*.c",	//所有.c的源码文件
                "-o",
                //"${fileDirname}\\${fileBasenameNoExtension}.exe",	//注释掉
                "${fileDirname}\\program.exe"	//编译后合并成一个.exe的可执行文件名
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

调试器launch.json

点击运行与调试，选择调试器选择C++(GDB/LLDB)，添加配置中选择C/C++：(gdb) launch

```json
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            //"program": "enter program name, for example ${workspaceFolder}/a.exe",
            "program": "${fileDirname}\\program.exe",	//修改成文件名
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            //"miDebuggerPath": "/path/to/gdb",
            "miDebuggerPath": "D:\\software\\msys64\\mingw64\\bin\\gdb.exe",	//修改成正确路径，注意规避反斜杠路径干扰
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ]
        }

    ]
}
```

## VScode Wsl2编译器调试配置：

1.创建tasks.json（编译）

代码界面点击终端，点击配置默认生成任务，C语言选择gcc，C++选择g++

2.创建Debug.json（调试）

代码界面点击运行，点击添加配置，选择C/C++:(gdb) Launch（启动），就可以调试了

## CMake VSCode

ctrl+shift+P，打开vscode命令行，输入cmake选择CMake Quick Start，输入项目名称（不能用保留关键字，如：all、clean、test等），Create C++或C项目，create executable，添加支持包如Test和Pack，添加所包含的源码，此时已生成CMakeLists.txt和build文件夹。

编译内核的选择，ctrl+shift+P，输入CMake选择CMake Select a kit，选择编译器版本即可

## CMake基本语法
版本要求，项目名称和编程语言
```txt
cmake_minimum_required(VERSION 2.8)	//cmake的最低版本要求

project(learn_cmake)	//工程名

project(learn_cmake CXX)	//工程名和编程语言
```
添加可执行文件
```
//单文件引用
add_executable(hello hello.cpp)	//生成的可执行文件名，和需要的依赖

//同一目录多文件引用
add_executable(hello hello.cpp myadd.cpp)	//统一目录下的多个依赖，只需要把所依赖的.cpp文件名称加入即可，同名称的.h文件无需添加

//同目录无限文件引用
aux_source_directory(s'r'c SRC_LIST)	//aux_source_directory(dir var),即把dir这个目录存在var变量中

add_executable(hello ${SRC_LIST})	//直接把单个添加的依赖用包含目录下所有文件的变量var替代，var变量的使用是${var}的方式引用

//头文件集合在另一个文件夹
include_directories(./inc_dir)	//添加头文件的搜索路径为根目录下的inc_dir目录
```

SET指令

```
SET(VAR )
```

示例

项目结构

```
/test
├── CMakeLists.txt
├── src/
│   ├── main.cpp
│   └── person.cpp
└── include/
    └── person.h
```

CMakeLists.txt

```
cmake_minimum_required(VERSION 3.10.0)	//cmake的版本要求

project(my_test VERSION 1.0 LANGUAGES C CXX)	//项目名称，版本，编写语言

include_directories(./include)	//添加头文件搜索路径

add_executable(test src/main.cpp src/person.cpp)	//可执行文件名和源代码依赖
```

## C

### 数据类型

基本数据类型：bool, char, int, float, double, void

**特别的，浮点型在输出时使用%g可以去除多余的0**

unsigned为无符号

特别的，字符串使用字符数组定义

```c
char str1[] = "Hello";  // 自动包含 '\0'
char str2[6] = {'H', 'e', 'l', 'l', 'o', '\0'};  // 手动添加 '\0'
char *str3 = "Hello";	//字符串常量，只读，无法修改	//使用%s格式化输出
char str4 = 'Hello';	//只存储最后一个字符'o'
```

```c
strlen(str)	//只返回不包含'\0'终止符的字符串长度
```

类型转换

隐式转换，自动发生，小转大，无失真

显式转换，强制类型转换运算符，可能会数据丢失或截断

```c
double PI = 3.1415926;
printf("%.7f\n", PI);
int x = 0;
x = (int)PI;
float y=0;
y=(float)PI;
printf("%d\n",x);
printf("%f\n",y);
return 0;
```

输出为

3.1415926
3
3.141593

**bool型**

C语言中使用bool型需要使用头文件

```c
#include <stdbool.h>
```

bool型可以使用数值或者true和false赋值，以%d格式直接输出结果为1或0

#### 数据类型长度

```c
int		//2或4字节
float 	//4字节
double	//8字节
char	//1字节
```

使用sizeof()获取数据类型长度，sizeof()的返回值是%lu，无符号长整型

基本格式指定符

```c
%d or %i	//int
%f or %F	//float
%lf		//double
%c		//char
%s		//strings
```

### 变量（C）

```c
type variable_name;	//变量定义
variable_name = new_value;	//变量的初始化
```

特别的，extern用于声明外部变量和函数，使用别的文件的变量，在这个变量所在的头文件进行声明，此时这个变量可以被使用该头文件的代码直接使用

extern一般用于声明，在.h文件中，声明变量或者函数（函数可以不加extern，但是最好加上，这样比较统一）；在其他文件要访问该变量函数时候，包含头文件就行

```c
//test.h 头文件
extern int i;
extern int j;
extern int k;
//...
//声明很多很多变量
```

调用

```c
# include<stdio.h>
# include"test.h"
//extern int i; 不用写了
//extern int j;不用写了
//extern int k;不用写了
//...
//声明很多很多变量,都不用写了，因为包含了头文件，声明都在头文件中
int main()
{
	printf("%d %d %d",i,j,k);
	return 0;
}
```

变量不显式初始化可能会是任意值

extern对于源码之间的调用

```c
//main.c
#include <stdio.h>

int x = 1;
int y = 2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf("result 为: %d\n", result);
    return 0;
}
```

```c
//addtwo.c
#include <stdio.h>
extern int x;
extern int y;
int addtwonum()
{
    return x + y;
}
```

**在这里，main.c中定义了x,y的全局变量，通过在addtwo的extern声明，使得addtwo可以直接调用，类似一个权限调用神明，谁要用到谁才声明。**

输出结果为3

联合编译后也是可以调用extern声明的变量

#### C中的左值与右值

左值指向内存位置，可以在赋值号（=）的左边和右边

右值指的是存储在内存中某些地址的数值，只能出现在赋值号的右边

### 常量

整数常量

可以是十进制、八进制或者十六进制。

前缀：0x或0X表示十六进制，0表示八进制，无前缀则默认为十进制

后缀：U表示unsigned无符号整数，L表示long长整数，可大写可小写



浮点常量

由整数、小数点、小数部分和指数部分组成

其中指数部分形式：

e后面的数字表示10的多少次方

如：

314159e-5L=3.14159

#### 常量定义

#define

一般写在全局，不写在函数体内，如果在函数体内写要用#undef 变量名结束作用域

```c
#define PI 3.14159	//前面的是常量名，后面的是常量值，不需要分号;结尾
```

const

```c
const int MAx=100;	//数据类型 常量名，常量值，需要分号结尾
```

#define仅进行文本替换，而const具有类型，运行时会分配内存，具有作用域限制

### C输入与输出

输入

```c
printf("%d",a);	//两个参数：变量类型，变量名，内容用双引号包裹
```

输出

**printf**()

```c
int a;
scanf("%d",&a);	//两个参数：变量类型，变量名，变量名前加一个&取地址符
```

多重输入

```c
int a;
char c;
char str[40];
scanf("%d %c",&a,&c);	//多重输入
scanf("%s",str);	//字符串输入，需保证写入的字符串定义时有足够的长度，不需要取地址，因为字符串变量就相当于首地址，scanf遇到空格换行符视为终止字符，意味着只能显示一个单词，不能读取空格
```

**fgets()** 读取整行

```c
char fullName[30];

printf("Type your full name: \n");
fgets(fullName, sizeof(fullName), stdin);	//三个参数：变量名，变量长度，stdin

printf("Hello %s", fullName);

// Type your full name: John Doe
// Hello John Doe
```

### 逻辑运算

#### 选择结构

if else，if else if，switch，三目运算符

三目运算符

```c
//if else写法
int time = 20;
if (time < 18) 
{
  printf("Good day.");
} else 
{
  printf("Good evening.");
}
```

```c
//三目运算写法
int time = 20;
(time<18) ? printf("Good day.") : printf("Good evening.");
```

#### 循环结构

while，do-while，for

do-while，至少无条件运行一次之后再做条件判断

```c
//do-while结构
int i = 0;
do {
  printf("%d\n", i);
  i++;
}
while (i < 5);
```

```c
//while结构
int i = 0;
printf("%d\n", i);
i++;
while (i < 5){
  printf("%d\n", i);
  i++;
}
```



### 存储类

用于定义C程序中变量或函数的储存位置，声明周期和作用域

放在所修饰的类型之前

共四类：auto ,register ,static ,extern

| 存储类   | 生命周期           | 作用域           | 默认初始化值          | 存储位置 |
| :------- | :----------------- | :--------------- | :-------------------- | :------- |
| auto     | 从声明到作用域结束 | 仅限声明块       | 未定义                | 栈       |
| static   | 程序整个运行期间   | 仅限声明块或文件 | 0（数值）或空（指针） | 静态区   |
| extern   | 程序整个运行期间   | 全局             | 0（数值）或空（指针） | 静态区   |
| register | 从声明到作用域结束 | 仅限声明块       | 未定义                | 寄存器   |

auto存储在栈中，只能用在函数内，只能修饰局部变量，是函数中的默认存储类，在函数开始时创建，结束时销毁。

register和auto类似，存储在CPU的寄存器，可以提高访问速度，但是最大尺寸很小，不在内存中，只用于需要快速访问的变量，比如计数器。

static的生命周期在整个程序运行期间，存在内存中，只能被声明的块或声明的文件使用，static静态变量的值只初始化一次，之后的值不会重置（并不是不会改变），只是初始化一次，之后调用保存上次函数退出时变量的值。

```c
learn()
{
static int a = 1; a ++;	//a只在函数第一次调用时初始化，之后每次重复调用函数，都不会再定义一次刷新值，使用上次函数退出时的值继续计算
printf("a = %d \n",a);
}
```

这种情况下输出1，2，3，4，5...

如果不使用static

```c
void learn()
{
int a = 1; a ++;	//每次调用函数都会重新初始化为1
printf("a = %d \n",a);
}
```

输出2，2，2，2，2

extern类则用于多个文件共享相同的**全局**变量或函数的时候，作为声明而不是定义或初始化

### 运算符

#### 算数运算符：加减乘除，求余，自增，自减

```c
+ - * / % ++ --
```

**++a和a++的区别在于++a先执行自增运算再执行程序运算，a++先执行程序运算再执行自增运算**

```c
int a=1,b=1;
printf("%d",a++);
printf("%d",++b);
```

输出为1，2

#### 关系运算符：两个值之间的比较

```c
== != > < >= <=
```

#### 逻辑运算符：与或非

```c
&& || !
```

#### 位运算符：

```c
& | ^ << >>
```

按位与：

两个数都为1则为1，否则为0

按位或：

### 数组

获取数组长度方法：

sizeof()表示所占用的空间

```c
int myNumbers[] = {10, 25, 50, 75, 100};
int length = sizeof(myNumbers) / sizeof(myNumbers[0]);	//使用数组总占空间除以单个元素所占用的空间

printf("%d", length);
```

#### C Strings 

C语言没有一个字符串类型用于字符串的创建，必须使用char字符数组来创建字符串

使用%s类型进行输出

```c
char greetings[] = "Hello World!";
greetings[0] = 'J';
printf("%s", greetings);
```

C中的字符串末尾有'\0'，表示字符串的结尾

字符串数组中的特殊符号的转义

在双引号""中的特殊符号的转义

```c
char txt[] = "We are the so-called "Vikings" from the north.";	//这样会报错，因为识别问题，把数组开头和vikings前的双引号识别在一起了
char txt[] = "We are the so-called \"Vikings\" from the north.";	//使用反斜杠将反斜杠后的字符识别为他自身
```

```c
\n	//换行
\t	//tab键
\0	//空字符	
```

C的库里有很多可用函数，需使用#include <string.h>引入

**strlen() 字符串长度**

```c
char txt[] = "Hello";
printf("%d", strlen(txt));	//输出5，自动忽略了'\0'，只输出有意义的字符的个数
printf("%d",sizeof(txt)/sizeof(txt[0]));	//输出6，把'\0'也算去了
```

因为sizeof返回的是占用的空间

strlen返回的是实际的字符

**strcat() 字符串连接**

```c
char str1[20] = "Hello ";
char str2[] = "World!";

// Concatenate str2 to str1 (result is stored in str1)
strcat(str1, str2);	//把str2的内容连接到str1，并存在str1里
//伪代码 str1 = str1 + str2

// Print str1
printf("%s", str1);	//输出Hello World！
```

str1的大小应该足够让str2接入

**strcpy() 把一个字符串的值赋给另一个字符串**

```c
char str1[20] = "Hello World!";
char str2[20];

// Copy str1 to str2
strcpy(str2, str1);	//把str1的值赋给str2
//伪代码 str2 = str1

// Print str2
printf("%s", str2);	//输出Hello World!
```

**strcmp() 比较两个字符串是否相等** 

```c
char str1[] = "Hello";
char str2[] = "Hello";
char str3[] = "Hi";

// Compare str1 and str2, and print the result
printf("%d\n", strcmp(str1, str2));  // 相等则返回0
//伪代码 str1 == str2 ? return 0 : return !0

// Compare str1 and str3, and print the result
printf("%d\n", strcmp(str1, str3));  // 不相等则返回非0的数字
//伪代码 str1 == str3 ? return 0 : return !0
```

### C 内存地址

使用&读取变量所在内存中的地址

```c
int a=43;
printf("%p",&a);	//%p是指针，&a取a的地址，格式为0x......,十六进制
```

指针允许我们操作内存中的数据，提高性能，这也使得C语言区别于java，python等其它语言

### C指针

指针即地址

```c
int myAge = 43;     // An int variable
int* ptr = &myAge;  // 给ptr这个指针型变量赋值，值就是myAge的地址

// Output the value of myAge (43)
printf("%d\n", myAge);

// Output the memory address of myAge (0x7ffe5367e044)
printf("%p\n", &myAge);

// Output the memory address of myAge with the pointer (0x7ffe5367e044)
printf("%p\n", ptr);

//*解引用，输出指针型变量对应地址所存的变量值 (43)
printf("%d\n", *ptr);
```

指针类型必须和所指向的变量的类型相匹配
 即，这是个指向这个类型的数据的地址

C语言中数组名称即指向数组第一个元素的指针，是第一个元素的内存地址

```c
int myNumbers[4] = {25, 50, 75, 100};

    // Get the memory address of the myNumbers array
    printf("%p\n", myNumbers);	//数组名可以直接用指针格式读取

    // Get the memory address of the first array element
    printf("%p\n", &myNumbers[0]);	//两个输出结果一致

	// Get the value of the first element in myNumbers
	printf("%d", *myNumbers);	//输出结果为myNumbers[0];
	
	printf("%d", *(myNumbers + 2))	//输出结果为myNumbers[0+2]，即类似迭代器的用法
        
    *myNumbers = 13;

	// Change the value of the second element to 17
	*(myNumbers +1) = 17;

	// Get the value of the first element
	printf("%d\n", *myNumbers);

	// Get the value of the second element
	printf("%d\n", *(myNumbers + 1));
```

### C函数

```c
returnType functionName(parameter1, parameter2, parameter3) {
  // code to be executed
}
```

字符串可以用char name[]直接传参

函数定义的 变量是无法在函数区域以外调用的

函数外部的相同变量名视为两个不同的变量

####  C变量作用域

函数定义的变量只能在函数内部使用，无法在函数外使用

函数外部创建的变量称为全局变量，并属于全局作用域，在哪都能调用

全局和函数内的相同变量名，则视为两个变量

应当避免重复变量名和全局变量的使用，合法但是有风险

```c
// Global variable x
int x = 5;

void myFunction() {
  // Local variable with the same name as the global variable (x)
  int x = 22;
  printf("%d\n", x); // Refers to the local variable x
}

int main() {
  myFunction();

  printf("%d\n", x); // Refers to the global variable x
  return 0;
}
//输出22 5
```

为了代码美观和优化，建议把函数声明和定义分开

### C语言递归

```c
int sum(int k);

int main() {
  int result = sum(10);
  printf("%d", result);
  return 0;
}

int sum(int k) {
  if (k > 0) {
    return k + sum(k - 1);
  } else {
    return 0;
  }
}
```

函数的自我调用，需要有递归条件和终止条件，否则会爆栈

### C数学函数

```c
#include <math.h>	//导入头文件
sqrt(16);	//求根
ceil(1.4);	//向上取整，输出2.0
floor(1.4);	//向下取整，输出1.0
pow(4,3);	//4的3次方，64
```

### C文件

C语言中创建，打开，读取，写入文件可以通过声明FILE类指针实现，用fopen()

```c
FILE *fptr;
fptr = fopen(filename, mode);	//filename是文件名，mode是使用方式
```

**文件创建**

```c
FILE *fptr;

// Create a file
fptr = fopen("filename.txt", "w");	//如果路径(这是编译在编译运行的目录下创建)，这是相对路径下没有这个文件，就直接创建一个

// Close the file
fclose(fptr);
```

**文件写入 mode("w")**（会覆盖原有的内容）

```c
FILE *fptr;

// Open a file in writing mode
fptr = fopen("filename.txt", "w");	//以写入模式打开文件

// Write some text to the file
fprintf(fptr, "Some text");		//向fptr指向的文件中写入"Some text"，覆盖原来的内容

// Close the file
fclose(fptr);
```

**文件内容追加 mode("a")** （在原有内容上添加） 

```c
FILE *fptr;

// Open a file in append mode
fptr = fopen("filename.txt", "a");

// Append some text to the file
fprintf(fptr, "\nHi everybody!");	//fprintf()写入

// Close the file
fclose(fptr);
```

**文件内容读取 mode("r")**

```c
FILE *fptr;

// Open a file in read mode
fptr = fopen("filename.txt", "r");	//读取模式打开

// Store the content of the file
char myString[100];		

// Read the content and store it inside myString
fgets(myString, 100, fptr);		//内容读取单行到创建的字符串

// Print the file content
printf("%s", myString);		//输出

// Close the file
fclose(fptr);	//关闭
```

### C结构体

一系列相关的变量集合，与C++的类和结构体相比没有成员函数，只有数据成员，也没有访问控制，只用于组织和管理多个不同类型的数据

```c
struct myStru{	//struct 声明是结构体，myStru是结构体名称
	int num1;
	char c;
};	//结束需要分号
```

使用.访问结构体成员

```c
struct myStructure
{
    int myNum;
    char myLetter;
};

int main()
{
    // Create a structure variable of myStructure called s1
    struct myStructure s1;	//创建一个名为s1的myStructure结构体

    // Assign values to members of s1
    s1.myNum = 13;		//通过.访问成员变量并赋值
    s1.myLetter = 'B';

    // Print values
    printf("My number: %d\n", s1.myNum);
    printf("My letter: %c\n", s1.myLetter);

    return 0;
}
```

结构体的字符串变量成员

```c
struct myStructure {
  int myNum;
  char myLetter;
  char myString[30]; // String
};

int main() {
  struct myStructure s1;
    
  // Trying to assign a value to the string
  s1.myString = "Some text";	//使用等号赋值会报错，因为C语言字符串是字符数组
    
  // Assign a value to the string using the strcpy function
  strcpy(s1.myString, "Some text");		//使用strcpy()赋值即可

  // Print the value
  printf("My string: %s", s1.myString);

  return 0;
}
```

快速定义结构体成员

```c
struct myStructure
{
    int myNum;
    char myLetter;
    char myString[30]; // String
};

int main()
{
    struct myStructure s1 = {1, 'c', "ashjkdfjkas"};	//变量值的类型和结构体的顺序一致

    // Trying to print the value
    printf("%d %c %s", s1.myNum, s1.myLetter, s1.myString);

    printf("\n");
    return 0;
}
```

结构体复制

```c
struct myStructure s1 = {13, 'B', "Some text"};
struct myStructure s2;

s2 = s1;	//使用=直接赋值
```

修改成员变量

```c
//字符和数字用等号'='直接修改
//字符串用strcpy()
```

### C联合体（Unions）

与结构体类似，可以存储不同类型的数据

但是结构体每个变量都有自己的存储空间，联合体的成员变量共享一个内存空间，所以一次只能用一个值

同一个位置存储不同类型的数据，每次只调用一个，需要节省空间

联合体声明

```c
union myUnion {        // Union declaration
  int myNum;           // Member (int)
  char myLetter;       // Member (char)
  char myString[30];   // Member (char array)
}; 

int main() {
  union myUnion u1;  // Create a union variable with the name "u1":
  return 0;
}
```

访问联合体成员使用.运算符

由于所有成员共享内存，更改其中一个会影响其他成员，最后分配的成员持有有效值。

```c
union myUnion
{
    int myNum;
    char myLetter;
    char myString[30];
};

int main()
{
    union myUnion u1;

    u1.myNum = 1000;

    // Since this is the last value written to the union, myNum no longer holds 1000 - its value is now invalid
    u1.myLetter = 'A';

    strcpy(u1.myString, "shdfjkask");

    printf("myNum: %d\n", u1.myNum);       // This value is no longer reliable
    printf("myLetter: %c\n", u1.myLetter); // Prints 'A'
    printf("myString: %s\n",u1.myString);
    printf("Size of union: %lu bytes\n", sizeof(u1));	
    return 0;
}
    /*输出
    myNum: 1717856371
    myLetter: s
    myString: shdfjkask
    Size of union: 32 bytes 大小取决于最大的成员*/
```

联合体的大小取决于成员变量中最大的成员

### C枚举

一种特殊类型，用于表示一组常量（即不可变值），创建时使用enum关键字，后面跟枚举名称，并用逗号分隔枚举项

```c
enum Level {
  LOW,
  MEDIUM,	//大写字母非必须
  HIGH		//最后一项无需逗号分隔
};
```

访问枚举需要创建变量，可以给这个变量赋值，值必须是枚举内部的一个元素

```c
enum Level myVar;
enum Level myVar = MEDIUM;
```

默认情况下，第一个元素的值为0，第二个为1，以此类推。也可以直接赋值，如果只给其中一个赋值，后面的变量会在它的基础上递增。

枚举用于给常量命名

### C语言内存管理

使用sizeof()读取所占用的内存空间

```c
int myInt;
float myFloat;
double myDouble;
char myChar;

printf("%lu\n", sizeof(myInt));      // 4 bytes
printf("%lu\n", sizeof(myFloat));    // 4 bytes
printf("%lu\n", sizeof(myDouble));   // 8 bytes
printf("%lu\n", sizeof(myChar));     // 1 byte
```

C语言中需要自己进行内存管理，在合适的时候进行内存释放

可以通过指针直接操作内存

但是必须谨慎，因为指针可以损坏存储在其他内存地址的数据

allocate 内存分配，分配方式取决于数据类型

C语言有两种内存，静态内存和动态内存

**静态内存**

在运行前就为变量预留的内存，也称为编译时内存分配

C语言在编译是自动为变量分配内存

这样很稳定，但是容易浪费未使用的内存

**动态内存**

在程序开始运行后分配的内存，也称为运行时内存分配

与静态内存不同，可以通过代码完全控制动态内存的分配

动态内存不属于变量，只能通过指针访问

动态内存分配使用malloc()，calloc()函数，必须包含<stdlib.h>

定义出来是个指针，即地址

```c
#include <stdlib.h>

int *ptr1 = malloc(size);	//动态存储分配函数，单个项目分配
int *ptr2 = calloc(amount, size);	//计数动态存储分配函数，多个项目，每个项目分配size个空间
free(*ptr)		//动态存储释放函数
realloc()		//分配调整函数
```

malloc()分配的内存中数据未初始化则不可预测，最好读取前先初始化

calloc()会写入0，因此效率低于malloc()

calloc比malloc多了分割和初始化为0

**为数据类型分配正确数量的内存的最佳方式是使用sizeof运算符：**

```c
int *ptr1, *ptr2;		//定义了指向int型的指针ptr1和ptr2
ptr1 = malloc(sizeof(*ptr1));	//sizeof(*ptr1)即sizeof(int)
ptr2 = calloc(1, sizeof(*ptr2));	//为一个变量分配*ptr的长度，即int型的大小
```

**对传统静态地址分配的优化**

```c
int students[20];
printf("%lu", sizeof(students)); // 80 bytes
//只写入了12个学生，8个学生也就是32个比特被浪费了


int *students;
int numStudents = 12;
students = calloc(numStudents, sizeof(*students));	//只为数组分配写入的学生数的长度
printf("%lu\n", students);		//输出一长串地址
printf("%lu\n", *students);		//输出0，因为calloc()初始化内存中的数据为0
printf("%lu\n", sizeof(students));	//输出8，是指针本身即地址的长度
printf("%lu\n", sizeof(*students));	//输出4，是单个数据的长度
printf("%lu\n", numStudents * sizeof(*students)); // 输出48，12个数据的总长度
```

**动态内存使用**

动态内存类似数组

```c
int *ptr;
int ptr[0];		//二者等价
ptr = calloc(4, sizeof(*ptr));
*ptr = 2;
ptr[1] = 4;
ptr[2] = 6;
printf("%d\n", *ptr);	//输出2
printf("%d %d %d %d\n", ptr[0], ptr[1], ptr[2], ptr[3]);	//输出2，4，6，0
ptr[0] = 1;
printf("%d\n", *ptr);	//输出1
printf("%d %d %d %d\n", ptr[0], ptr[1], ptr[2], ptr[3]);	//输出1，4，6，0
printf("\n");
return 0;
```

**！！！动态内存没有自己的数据类型，可以根据指针类型解释为不同类型**

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

int main()
{
    int *ptr1 = malloc(4);	//创建一个整型指针，分配四个内存
    char *ptr2 = (char *)ptr1;	//创建一个字符型指针和整型指针指向同一块内存
    *ptr1 = 3158581;	//存入520的ascii码16进制拼接数
    //将这个数转成16进制后按%c的位分割，分别对应字符'5' '2' '0'
    printf("%d is %c %c %c %c", *ptr1, ptr2[0], ptr2[1], ptr2[2], ptr2[3]);		//输出5 2 0
    printf("\n");
    return 0;
}
```

**内存重新分配**

如果内存预留量不足，可以重新分配改变内存，会保存存储中的数据，使用realloc（ptr，size）

```c
int *ptr2 = realloc(ptr1, size);	//realloc使用方法
```

**realloc使用实例**

```c
int *ptr1, *ptr2, size;

// Allocate memory for four integers
size = 4 * sizeof(*ptr1);
ptr1 = malloc(size);
*ptr1=1;
ptr1[1]=2;
ptr1[2]=3;
ptr1[3]=4;
printf("%d bytes allocated at address %p \n", size, ptr1);	//输出地址
printf("%d %d %d %d\n",ptr1[0],ptr1[1],ptr1[2],ptr1[3]);
// Resize the memory to hold six integers
size = 6 * sizeof(*ptr1);
ptr2 = realloc(ptr1, size);
ptr2[4]=5;
ptr2[5]=7;
printf("%d bytes reallocated at address %p \n", size, ptr2);	//输出地址，与ptr1的地址一致，没有更改，有些情况会从别的地方开
printf("%d %d %d %d %d %d\n",ptr1[0],ptr1[1],ptr1[2],ptr1[3],ptr1[4],ptr1[5]);	//依然能调用ptr1，如果返回的ptr2地址改变了，这就是非法操作
printf("%d %d %d %d %d %d\n",ptr2[0],ptr2[1],ptr2[2],ptr2[3],ptr2[4],ptr2[5]);
```

如果返回的内存变化了，也就是ptr1和ptr2不相等，那么此时原本的ptr1访问内存就非法了

```c
int *ptr1, *ptr2;

// Allocate memory
ptr1 = malloc(4);

// Attempt to resize the memory
ptr2 = realloc(ptr1, 8);

// Check whether realloc is able to resize the memory or not
if (ptr2 == NULL) {		//无法分配，realloc()返回了空指针
  // If reallocation fails
  printf("Failed. Unable to resize memory");
} else {
  // If reallocation is sucessful
  printf("Success. 8 bytes reallocated at address %p \n", ptr2);
  ptr1 = ptr2;  // Update ptr1 to point to the newly allocated memory
}
```

在分配内存的时候应始终保持空指针错误检查

```
if (ptr == NULL)
```

两个解决方法，使用完直接释放掉，或者直接赋值给原指针

```c
int *ptr1, size;

    // Allocate memory for four integers
    size = 4 * sizeof(*ptr1);
    ptr1 = malloc(size);
    *ptr1=1;
    ptr1[1]=2;
    ptr1[2]=3;
    ptr1[3]=4;
    printf("%d bytes allocated at address %p \n", size, ptr1);
    printf("%d %d %d %d\n",ptr1[0],ptr1[1],ptr1[2],ptr1[3]);
    // Resize the memory to hold six integers
    size = 6 * sizeof(*ptr1);
    ptr1 = realloc(ptr1, size);		//赋值给原指针
    ptr1[4]=5;
    ptr1[5]=7;
    printf("%d bytes reallocated at address %p \n", size, ptr1);
    printf("%d %d %d %d %d %d\n",ptr1[0],ptr1[1],ptr1[2],ptr1[3],ptr1[4],ptr1[5]);
```

完成使用后，应当释放内存，使用free()

```c
int *ptr;
ptr = malloc(sizeof(*ptr));

free(ptr);		//释放指针内存
ptr = NULL;		//释放内存之后把指针置空，避免野指针，在free后必须立即释放
```

```c
int *ptr;
ptr = malloc(sizeof(*ptr)); // Allocate memory for one integer

// If memory cannot be allocated, print a message and end the main() function
if (ptr == NULL) {
  printf("Unable to allocate memory");
  return 1;
}

// Set the value of the integer
*ptr = 20;

// Print the integer value
printf("Integer value: %d\n", *ptr);

// Free allocated memory
free(ptr);		//释放指针内存

// Set the pointer to NULL to prevent it from being accidentally used
ptr = NULL;		//释放后立即将指针置空，防止野指针
```

**内存泄漏**

在动态内存被分配但是从未释放的时候

如果内存泄漏发生在循环和函数等频繁调用的情况，会使用很多内存并拖慢电脑运行速度

如果在释放内存（free）之前就丢失了指向动态内存的指针，就有内存泄露的风险，必须小心跟踪指向动态内存的指针

**指针被覆盖了**

```c
int x = 5;
int *ptr;
ptr = calloc(2, sizeof(*ptr));
ptr = &x;
```

指针被指向了x，所以calloc分配的内存无法访问

**指针只存在于函数内部**

```c
void myFunction() {
  int *ptr;		//指针只在函数体内定义，如果不释放，那么后面无法访问且始终占用空间
  ptr = malloc(sizeof(*ptr));
}

int main() {
  myFunction();
  printf("The function has ended");
  return 0;
}
```

可以在函数结束前释放内存

**重新分配失败时，指针会丢失，造成内存泄漏**

```c
int* ptr;
ptr = malloc(sizeof(*ptr));
ptr = realloc(ptr, 2*sizeof(*ptr));		//若realloc失败。则ptr变成空指针，原始内存地址则泄漏且无法恢复
```

**内存管理实例**

```c
struct list {
  int *data; // Points to the memory where the list items are stored
  int numItems; // Indicates how many items are currently in the list
  int size; // Indicates how many items fit in the allocated memory
};

void addToList(struct list *myList, int item);

int main() {
  struct list myList;
  int amount;

  // Create a list and start with enough space for 10 items
  myList.numItems = 0;
  myList.size = 10;
  myList.data = malloc(myList.size * sizeof(int));

  // Find out if memory allocation was successful
  if (myList.data == NULL) {
    printf("Memory allocation failed");
    return 1; // Exit the program with an error code
  }

  // Add any number of items to the list specified by the amount variable
  amount = 44;
  for (int i = 0; i < amount; i++) {
    addToList(&myList, i + 1);
  }

  // Display the contents of the list
  for (int j = 0; j < myList.numItems; j++) {
    printf("%d ", myList.data[j]);
  }

  // Free the memory when it is no longer needed
  free(myList.data);
  myList.data = NULL;

  return 0;
}

// This function adds an item to a list
void addToList(struct list *myList, int item) {		//传址引用

  // If the list is full then resize the memory to fit 10 more items
  if (myList->numItems == myList->size) {
    myList->size += 10;
    myList->data = realloc( myList->data, myList->size * sizeof(int) );
  }

  // Add the item to the end of the list
  myList->data[myList->numItems] = item;
  myList->numItems++;
}
```

  **访问结构体或类的成员的操作符**

->和.

```c
//.操作符用于直接访问对象的成员
struct Person
{
	char name[20];
	int age;
};

int main()
{
    struct Person p = {"Chen", 24};
    p.age=25;		//直接访问p的成员
    return 0;
}
```

```c
//->操作符用于通过指针间接访问对象的成员
struct Point {
    int x;
    int y;
};

int main() {
    struct Point* ptr = (struct Point*)malloc(sizeof(struct Point));	//结构欧体指针ptr
    ptr->x = 10;	// 等价于 (*ptr).x = 10;
    ptr->y = 20;	// 等价于 (*ptr).y = 20;
    printf("Point: (%d, %d)\n", ptr->x, ptr->y);
    free(ptr);
    return 0;
}
```

### C预处理器和宏替换

在真正的编译之前开始运行，处理包含文件和宏定义问题

#### 预处理器

在编译前由预处理器处理的命令，用#开头，无需分号；结尾

```c
#include <stdio.h>		//标准库，用<>包裹
#include "myfile.h"		//自定义头文件，用""包裹
```

**宏替换**

```c
#define PI 3.14	//在程序编译之前，就把PI替换成3.14
#define SQUARE(x) ((x) * (x))	//也可以宏定义函数，用括号包裹，避免识别错误

int main() {
  printf("%.2f\n",PI);	//输出3.14
  printf("Square of 4: %d\n", SQUARE(4));	//输出16
  return 0;
}
```

#### #ifdef和#ifndef

根据是否定义变量决定是否执行所包含的代码

```c
//ifdef检查是否定义了宏，有则执行
#define DEBUG	//宏定义了DEBUG

int main() {
  #ifdef DEBUG		//检查是否定义了DEBUG
    printf("Debug mode is ON\n");	//定义了，所以执行输出
  #endif	
  return 0;
}
```

```c
//ifndef检查是否定义了宏，没有定义则执行
#define DEBUG	//宏定义了DEBUG

int main() {
  #ifndef DEBUG		//检查是否定义了DEBUG
    printf("Debug mode is ON\n");	//定义了，所以不执行输出
  #endif	
  return 0;
}
```

一般是检查是否定义，ifdef是检测宏并调用宏内容，ifndef用于防止重复定义和引用

## C++

跨平台的高性能语言

作为C的扩展，给开发者高等级权限操控系统资源和内存

和C的区别在于类和对象

### 命名规则

不能是关键字

由字母数字下划线组成

首字符为字母或下划线

区分大小写

### 常量

```c++
#define ll long long	//把ll的值定义为long long
const 
```

### 单文件

C++编译：

```
g++ main.cpp	//编译main.cpp
g++ main.cpp -o main	//编译后指定输出文件名
./main	//运行编译后的程序
```

C++编译与连接

```
g++ -c mian.cpp -o main.o	//编译生成main.o，中间状态，变成了二进制，没有和系统组件连接起来
g++ main.o -o mian	//把编译完未连接的中间文件连接上生成main.exe可执行文件
```

### 多文件

```
g++ main.cpp mymath.cpp -o main	//多文件的编译和链接
```

```c++
//main.cpp
#include <iostream>
#include "mymath.h"

using namespace std;

int main(){
    cout << "Hello World" << endl;
    int a=10;
    int b=20;
    int c=add(a,b);
    cout << a << "+" << b << "=" << c << endl;
    return 0;
}
```

```cpp
//mymath.cpp
#include <iostream>
#include "mymath.h"

using namespace std;

int main(){
    cout << "Hello World" << endl;
    int a=10;
    int b=20;
    int c=add(a,b);
    cout << a << "+" << b << "=" << c << endl;
    return 0;
}
```

```cpp
//mymath.h
int add(int a,int b);
```

### C++指针与引用

*指针取地址的值

&取地址或别名引用

```c++
#include<iostream>
#include<string>
using namespace std;

//传值
void swap(int x,int y){
    cout << x << " " << y << endl;
    int temp;
    temp=x;
    x=y;
    y=temp;
    cout << x << " " << y << endl;
}
//引用
void swap2(int &x,int &y){
    cout << x << " " << y << endl;
    int temp;
    temp=x;
    x=y;
    y=temp;
    cout << x << " " << y << endl;
}
//传址后解引用
void swap3(int *x,int *y){
    cout << x << " " << y << endl;
    int temp=*x;
    *x=*y;
    *y=temp;
    cout << x << " " << y << endl;
}
int main(){
    int a=7,b=5;
    swap(a,b);
    cout << a << " " << b << endl;
    swap2(a,b);
    cout << a << " " << b << endl;
    swap3(&a,&b);
    cout << a << " " << b << endl;
    return 0;
}
```

### 函数重载

同函数名，但是不同的传入参数是可以共存的

```c++
#include<iostream>
#include<string>
using namespace std;

//传入引用
void swap(int &x,int &y){
    cout << x << " " << y << endl;
    int temp;
    temp=x;
    x=y;
    y=temp;
    cout << x << " " << y << endl;
}
//传入地址
void swap(int *x,int *y){
    cout << x << " " << y << endl;
    int temp=*x;
    *x=*y;
    *y=temp;
    cout << x << " " << y << endl;
}
int main(){
    int a=7,b=5;
    swap(a,b);
    cout << a << " " << b << endl;
    swap(&a,&b);
    cout << a << " " << b << endl;
    return 0;
}
```

### 结构体与类和对象

结构体的创建和调用

成员变量和方法默认是public，默认类外可直接调用

```c++
#include<iostream>
#include<string>
using namespace std;

struct student{
    char name[30];
    int age;
    char id[13];
    void print(){
        cout << name << " " << age << " " << id << endl;
    }
};
int main(){
    struct student s1={"chenjiaxi",24,"202312060404"};
    cout << s1.name << endl;
    cout << s1.age << endl;
    cout << s1.id << endl;
    s1.print();
}
```

类的创建和调用，默认权限是private，需要通过public::显式公开权限

方法函数在类定义内定义

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;

class stu{
public:
    string name;
    int age;
    string id;
    void print(){	//在类内直接定义方法函数
    	cout << name << " " << age << " " << id << endl;
	}
};

int main(){
    stu s2;
    s2.name="cjx";
    s2.age=5;
    s2.id="131605";
    s2.print();
}
```

成员函数外部定义

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;

class stu{
public:
    string name;
    int age;
    string id;
    void print();	//类的内部声明方法函数名
};

//在外部定义方法
void stu::print(){
    cout << name << " " << age << " " << id << endl;
}

int main(){
    stu s2;
    s2.name="cjx";
    s2.age=5;
    s2.id="131605";
    s2.print();
}
```

创建构造函数后默认的空构造函数被覆盖

构造函数直接使用类名

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;

class stu{
public:
    string name;
    int age;
    string id;
    stu(string x,int y,string z){	//构造函数
        name = x;
        age = y;
        id = z;
    }
};

int main(){
    stu s2("cjx",13,"131605");
    s2.print();
}
```

把变量封装起来无法直接通过s2.name直接访问，只能通过方法修改和获得

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;

public:
    void print(){
        cout << name << " " << age << " " << id << endl;
    }
    stu(string x,int y,string z){
        name = x;
        age = y;
        id = z;
    }
    void setName(string a){
        name = a;
    }
    string getName(){
        return name;
    }
};

int main(){
    stu s2("cjx",13,"131605");
    s2.print();
    cout << s2.getName() << endl;
    s2.setName("xjckvhshj");
    cout << s2.getName() << endl;
}
```

多态：

运行时多态

```c++
#include<iostream>
#include<cstring>
#include<string>
using namespace std;

class animal{
public:
    void animalSound(){
        cout << "The animal makes a sound" << endl;
    }
};

class pig : public animal {
public:
    void animalSound() {
        cout << "The pig says: wee wee" << endl;
    }
};

class dog : public animal{
public:
    void animalSound(){
        cout << "The dog says: bow wow" << endl;
    }
};

int main(){
    animal a;
    pig b;
    dog c;
    a.animalSound();
    b.animalSound();
    c.animalSound();
}
```

### sizeof()

```c++
sizeof()
```

